Maybe Ideas:
1. Give get, post, .... methods option directly on DoomServer Object

    e.g.
    server.get("/user", (req) -> {
        processing...
        return Response();
    });

2. improve annotation processing
3. new project with basic scaffolding using gradle plugin/cli command like maven extension artifact commands.

useful links:
https://medium.com/faun/continuous-integration-of-java-project-with-github-actions-7a8a0e8246ef
https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful

Checklist:
- MultiPart form-data support in both request and response
- handle all types of content. i.e. text, json, file, and etc...
    -- this gave a pretty good headache, I was trying to use multiple instances, object reference and generics directly
    -- but the solution was to use a wrapper class with generics

- feat: handle getting all classes from project.
- bug: handling response masking by notfound in route middleware error.
- bug: handle a request getting called multiple times.
    -- source of error: Request object is getting created multiple times in middleware and controller. Each middleware is creating new request object.
    -- change this implementation to use common request object is each handler i.e. middleware and main one.

- handle path parameters in url. e.g.: api/example/resource/{john} - tomorrows priority
    - just got a brilliant idea, instead of coming up with a separate regex pattern which will be useless in this case.
      I just have to convert the route into a regex itself.

- handle query parameters in url. e.g. api/example?user=john
    choose b/w options:

    - Query parameters in function paramters e.g. getName(Request req, @QueryParam("id") id);
        -this method is better because we will get compiler check on parameters, but when calling .getQueryParam there can be typo chances.
        -the difficulty is this how to pass variable no of parameters to function.
    - Query parameters in Request object e.g. id = req.getQueryParam("id");
        -this method is much easier to implement

- middleware/interceptors - think about design and all/ no idea yet
    choose b/w two:

    - Middleware defined separately acc to path
        - This approach will have A interface with single method(SAM) which middleware implement
        - and a @MiddleWare for path regex

    - Middleware defined separately and then added to route as class scoped or method scoped (going with this approach)
        - This approach will have A interface with single method(SAM) which middleware implement
        - and a @MiddleWare which will be applied to class or route method and takes list of middlewares in order.
        - also give option for global middleware with server object

- handle multithreading properly and other resources
- code refactoring and documentation
- handle parsing path in controller. if path is api/example/response and controller is api/example then we must check for substring

Points:

- POST request will have path param but no query param. It will also have body.
- GET req can't have body.

*Note:
GET is idempotent(meaning multiple requests won't change the state of the server) but POST, PUT, DELETE are not because they do change state.
If the operation has side effects, then it is certainly not 'safer' to use the GET method because the browser assumes all GETs are idempotent. search engines also convert that in a nightmare, as Google will safely "click" all links with GET request, but will omit everything else. It's not so safe leaving a service that an innocent crawler can accidentally wipe the database.

for versioning :-
a.b.c

a - major, when product is considered complete with decided features
b - increment for each feature completed
c - increment for bug fixes or small improvements
