Maybe Ideas:
1. Give get, post, .... methods option directly on DoomServer Object

    e.g.
    server.get("/user", (req) -> {
        processing...
        return Response();
    });

2. improve annotation processing
3. new project with basic scaffolding using gradle plugin/cli command like maven extension artifact commands.

useful links:
https://medium.com/faun/continuous-integration-of-java-project-with-github-actions-7a8a0e8246ef
https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful

Checklist:

3. handle form data
4. handle all types of content. i.e. text, json, file and etc...
9. handle sending and receiving all types of data in response and body.
10. handle receiving body in post request

1. handle path parameters in url. e.g.: api/example/resource/{john} - tomorrows priority
    - just got a brilliant idea, instead of coming up with a separate regex pattern which will be useless in this case.
      I just have to convert the route into a regex itself.

2. handle query parameters in url. e.g. api/example?user=john
    choose b/w options:

    - Query parameters in function paramters e.g. getName(Request req, @QueryParam("id") id);
        -this method is better because we will get compiler check on parameters, but when calling .getQueryParam there can be typo chances.
        -the difficulty is this how to pass variable no of parameters to function.
    - Query parameters in Request object e.g. id = req.getQueryParam("id");
        -this method is much easier to implement

5. middleware/interceptors - think about design and all/ no idea yet
    choose b/w two:

    - Middleware defined separately acc to path
        - This approach will have A interface with single method(SAM) which middleware implement
        - and a @MiddleWare for path regex

    - Middleware defined separately and then added to route as class scoped or method scoped (going with this approach)
        - This approach will have A interface with single method(SAM) which middleware implement
        - and a @MiddleWare which will be applied to class or route method and takes list of middlewares in order.
        - also give option for global middleware with server object

6. handle multithreading properly and other resources
7. code refactoring and documentation
8. handle parsing path in controller. if path is api/example/response and controller is api/example then we must check for substring

Points:

1. POST request will have path param but no query param. It will also have body.
2. GET req can't have body.

*Note:
GET is idempotent(meaning multiple requests won't change the state of the server) but POST, PUT, DELETE are not because they do change state.
If the operation has side effects, then it is certainly not 'safer' to use the GET method because the browser assumes all GETs are idempotent. search engines also convert that in a nightmare, as Google will safely "click" all links with GET request, but will omit everything else. It's not so safe leaving a service that an innocent crawler can accidentally wipe the database.

for versioning :-
a.b.c

a - major, when product is considered complete with decided features
b - increment for each feature completed
c - increment for bug fixes or small improvements
